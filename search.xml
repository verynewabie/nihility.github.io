<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串哈希</title>
      <link href="/2022/06/20/zi-fu-chuan-ha-xi/"/>
      <url>/2022/06/20/zi-fu-chuan-ha-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>哈希是一种映射方法，我们用哈希把万物映射成一个整数值，字符串哈希就是把字符串映射为一个整数值，这样我们就能快速判断两个字符串是否相同。字母集$T$就是我们用到所有字母的集合，$|T|$就是其大小。$H$为哈希函数,$S$为字符串，$n$为其长度，$H(S)$即为字符串$S$的哈希值，$mod$是模数</p></blockquote><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>字符串哈希最常用的方法就是把整个字符串当成一个$K$进制数，其中$K\ge |T|$，而我们遇到的题目中一般都满足$|T|\le 128$，我们可以选择$K=131、137$等等数值，<strong>最好是质数</strong>，因为我们计算的时候整数的值过大，我们需要取模。</p><p>按照这种方法，假设有字符串$S$，且其下标从1开始，那么$H(S)=\sum_{i=1}^{n}S[i]\times K^{n-i+1}$，这个值过大，我们需要取模，模数肯定也要选择<strong>比较大的质数</strong>，模数小会很容易出现冲突，即两个并不相同的字符串哈希值相同，我们可以取$mod=1e9+7、1e9+9、1610612741$，其中第三个是比较好的哈希模数。（因为前两个用的太多了，出题人更容易卡我们）但是就算如此，当我们需要检测的次数特别多时，我们还是很容易出错，因此我们可以用不同的$K$和$mod$算两个哈希值，这样出错概率就会<strong>大大降低</strong>。</p><p>另外，根据<a href="https://baike.baidu.com/item/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA/2715290?fr=aladdin">生日悖论</a>，我们使用的<strong>模数最好大于等于检测次数的平方</strong>。</p><h2 id="子串哈希"><a href="#子串哈希" class="headerlink" title="子串哈希"></a>子串哈希</h2><p>由上面的内容，我们很容易知道$H(S[l\sim r])=(S[l]\times K^{r-l}+\cdots + S[r])%mod$。</p><p>假设我们令$F[i]=H(S[1\sim i])$，那么有</p><p>$F[l-1]=(S[1]\times K^{l-2}+S[2]\times K^{l-3}+\cdots+S[l-1])%mod$</p><p>$F[r]=(S[1]\times K^{r-1}+S[2]\times K^{r-2}+\cdots +S[r])%mod$</p><p>我们易知$H(S[l\sim r])=F[r]-F[l]\times K^{r-l+1}$</p><p>因此我们只要求出$S$对应的$F$，就能快速求出其子串的哈希。</p><p>而我们也易得$F[i+1]=F[i]\times K+S[i+1]$</p><p>另外，如果给我们$H(S[l_{1}\sim r_{1}])$和$H(S[l_{2}\sim r_{2}])$那么我们可以快速得到这两个字串拼接起来后得到的字符串的哈希值为$H(S[l_{1}\sim r_{1}])\times K^{r_{2}-l_{2}+1}+H(S[l_{2}\sim r_{2}])$，由此我们想到如果我们要修改字符串的话，我们就可以用线段树来维护字符串的哈希值了！</p><h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><p>这几天军训比较懒，所以就没有结合例题来讲，放几道推荐题目吧。</p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3370">字符串哈希</a></p><p>思维题+用字符串哈希判断回文串：<a href="https://codeforces.com/gym/103729/problem/J">Palindrome Reversion</a></p><p>二分+字符串哈希找最长回文串：<a href="https://www.luogu.com.cn/problem/SP7586">Number of Palindromes</a></p><p>线段树+字符串哈希：<a href="https://codeforces.com/contest/580/problem/E">Kefa and Watch</a></p>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2022/06/19/bing-cha-ji/"/>
      <url>/2022/06/19/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章我们不再讲解并查集的基础知识，主要讲解并查集的一些拓展用法，需要补一下基础知识的同学我推荐这一篇文章：<a href="https://blog.csdn.net/weixin_38279101/article/details/112546053">并查集</a>，另外这篇文章里讲到的按秩合并，也可以是把小的集合合并到大的集合上面，这样更容易代码实现，我们只需多维护一个集合的大小就可以了。另外按秩合并在不用可撤销并查集的地方我们基本上用不到，毕竟我们路径压缩后就很优秀了，而可撤销并查集不能使用路径压缩，我们为了保证效率就会使用按秩合并。另外提一嘴，使用路径压缩的并查集平均复杂度就是$O(n)$了。</p></blockquote><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>我们在维护并查集的同时维护每个节点到当前它的父亲节点的距离，就能维护各个元素之间一些具有传递性的属性。感觉这一点干讲不知道怎么讲，我们就拿道题来看吧，第十三届篮球包（蓝桥杯）省赛CA组最后一题：</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206190959038.png" alt="image-20220619095950928"></p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191000153.png" alt="image-20220619100012085"></p><p>首先我们看到区间和肯定会想到并查集，我们用$s_{i}$表示$\sum_{j=1}^{i} A_{i}$，那么如果我们已知$\sum_{i=l}^{r} A_{i}$，就相当于知道了$s_{r}-s_{l-1}$，如果最终只是问我们答案能否确定，那肯定很简单，我们用并查集维护$s$的集合，我们只需要先合并它给我们的所有$r$和$l-1$，然后查询的时候看$l-1$和$r$是否在一个集合内即可。然后我们另外开一个数组$d$记录每个点$x$的父亲节点和它之间的差$s[p[x]]-s[x]$， $p[x]$表示$x$的父亲，至于$d$数组的初始化就很简单了，$d[i]=0$，因为刚开始$p[i]=i$，然后先看代码，我再具体讲解。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> l<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//read就是写的快读</span>LL sum<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>l<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//前缀和为s[r]-s[l-1]</span>LL a<span class="token operator">=</span>l<span class="token punctuation">,</span>b<span class="token operator">=</span>r<span class="token punctuation">;</span>l<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找到l-1，r的父亲p[l-1],p[r]</span><span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">!=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>    p<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token punctuation">;</span><span class="token comment">//合并集合，这里的l，r已经不是原来的l，r</span>    d<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>sum<span class="token operator">+</span>d<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">-</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//更新距离，为什么这么写，看下面的图应该就理解了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191142837.png" alt="image-20220619114246792"></p><p>由于$find$函数调用的途中我们会改变节点的父亲，因此我们的$find$函数也需要改写。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> root<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先记录下找到的父亲</span>        d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+=</span>d<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//x到新父亲的距离=x到旧父亲的距离+旧父亲到新父亲的距离</span>        p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191156491.png" alt="image-20220619115605445"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//查询就比较简单了</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">--</span><span class="token punctuation">;</span>LL x<span class="token operator">=</span>a<span class="token punctuation">,</span>y<span class="token operator">=</span>b<span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">!=</span>b<span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"UNKNOWN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">-</span>d<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//注意，这里是d[x]-d[y]而不是d[a]-d[b]，因为a，b已经变成它们的父亲了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们差不多了解了带权并查集，这里我们维护的是元素间的差，我们也可以维护其它类型的权值，大家可以自己找点题练习。</p><h2 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h2><p>我们知道并查集能维护具有传递性的关系，但当我们遇到诸如“敌人的敌人是朋友”这类关系时，普通的并查集就没那么好用了，这时候我们的扩展域并查集就登场了。我们把并查集的规模扩大一倍，并划分为两个种类，在相同种类中合并两个元素表示他们是朋友，在不同种类中合并表达他们是敌人，这样一个人敌人的敌人就和他在同一个种类中，就维护了“敌人的敌人是朋友”的这种关系。</p><p>我们来道例题并写出代码加深一下理解。</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191250142.png" alt="image-20220619125054061"></p><p>我们还是用前缀和的思想，用$sum[i]$表示$s[1\sim i]$中1的个数，如果$l\sim r$中有偶数个$1$，我们易知$sum[l-1]$和$sum[r]$的奇偶性相同，奇数个则相反，而对于$sum[i]$，假设$sum[y]$与它奇偶性相反，那么与$sum[y]$奇偶性相反的数奇偶性与$sum[i]$相同，符合我们上面阐述的关系，因此这题我们可以用扩展域并查集来写。另外这题$N$的范围较大，需要离散化，我图个方便就直接写了，懂思路才是最重要的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//我们用0~n表示0~n的第一个种类，n+1~2*n+1表示0~n的第二个种类</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">int</span> pa1<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>pb1<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pa2<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token operator">+</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>pb2<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token operator">+</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是偶数个时，这二者奇偶性相同</span><span class="token keyword">if</span><span class="token punctuation">(</span>pa1<span class="token operator">==</span>pb2<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//如果发现a，b奇偶性不同，说明矛盾</span><span class="token comment">//否则无矛盾，正常合并</span>p<span class="token punctuation">[</span>pa1<span class="token punctuation">]</span><span class="token operator">=</span>pb1<span class="token punctuation">;</span>p<span class="token punctuation">[</span>pa2<span class="token punctuation">]</span><span class="token operator">=</span>pb2<span class="token punctuation">;</span><span class="token comment">//奇数的情况也差不多，就不多写了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外这题也能用带权并查集来写，我们维护的权值只有1和0，两点之间距离为0时说明奇偶性相同，为1时说明奇偶性不同，然后计算距离时对2取模即可。</p><p>最后留一道不错的练习题：<a href="https://www.luogu.com.cn/problem/P2024">食物链</a>(带权并查集和扩展域并查集都能写)</p><h2 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h2><p>顾名思义，可撤销并查集就是能撤销我们的合并操作的并查集，要撤销，我们就需要存储每一次修改的信息，然后就行回退，这时再使用路径压缩就会出现问题，如图。</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191353327.png" alt="image-20220619135318193"></p><p>因此我们使用按秩合并，此时每次find的时间复杂度为$O(log n)$，那我们怎么撤销呢？我们发现，我们每次合并只会改变一个集合的大小和一个点的父亲，我们把这些都记录下来，就能撤销了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> his_p<span class="token punctuation">,</span>his_sz<span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>sz<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//sz[i]表示以i为根的集合的大小，初始时sz[i]=1</span><span class="token comment">//我们每进行一次合并his_p和his_sz的就会多一个元素，因此我们可以根据vector的大小来标识不同的历史版本</span><span class="token comment">//不带路径压缩的find</span><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span>x<span class="token punctuation">)</span> x<span class="token operator">=</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> x<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token comment">//合并部分代码</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> pa<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>pb<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>pa<span class="token operator">==</span>pb<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token operator">&lt;</span>sz<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>       his_sz<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>pa<span class="token punctuation">,</span>sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//pa的大小改变了</span>       sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token operator">=</span>sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token operator">+</span>sz<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//小的合并到大的上，即pb合并到pa上</span>       his_p<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>pb<span class="token punctuation">,</span>p<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//pb的父亲改变了</span>       p<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token operator">=</span>pa<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token comment">//撤销</span><span class="token keyword">void</span> <span class="token function">roll</span><span class="token punctuation">(</span><span class="token keyword">int</span> his<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//回到vector大小为his的版本</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>his_p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>his<span class="token punctuation">)</span><span class="token punctuation">{</span>           p<span class="token punctuation">[</span>his_p<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">=</span>his_p<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>           his_p<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           sz<span class="token punctuation">[</span>his_sz<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">=</span>his_sz<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>           his_sz<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后丢道练习题：<a href="https://codeforces.com/contest/891/problem/C">Envy</a></p><p>并查集就写到这里了，最重要的还是刷题练习！😋</p><h2 id="废话部分"><a href="#废话部分" class="headerlink" title="废话部分"></a>废话部分</h2><p>今天上午领了军训服装，明天就要开始军训了，祈祷下面两周天天下雨🙏😭。.</p><p>另外这个latex公式加载需要一些时间，因此公式炸了耐心等一下估计就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客记</title>
      <link href="/2022/06/18/da-jian-bo-ke-ji/"/>
      <url>/2022/06/18/da-jian-bo-ke-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>大家好，我是来自河南周口的一名大学生，没错，就是那个流出人口数全国第一的城市。虽然我来自一个很卷的地方，但我真的一点都不卷，即使学校逼着我们卷。高中三年我看了不少小说，具体数目实在不记得了，估计在50~100本之间？甚至高三还在看很多小说，还TM犯贱地看了《人间失格》，还看了一堆《看天下》，《环球人物》这类的杂志。高考挺让人失望的（指让学校），最后为了稳保我能上计算机专业，我选择了WHU，大一上学期偶然接触了算法竞赛，自那以后便一发不可收拾，即使临近期末考试并且我还没复习，我也会老想着算法，它和数学挺像的，但我感觉它比数学更迷人。现在我应该算是WHU的一名ACMer？可是比赛却打的稀碎，校内新生赛究极坐牢，蓝桥杯耻辱省二，湖北省赛被题目暴打，一个字概括我：菜👎。专业分流选了软工。目前爱好：单推真白花音；打rouge类游戏；算法竞赛，打乒乓球。</p><h1 id="简单记录"><a href="#简单记录" class="headerlink" title="简单记录"></a>简单记录</h1><p>现在是2022年6月18日0点32分，现在差不多搞完了我的博客搭建，其实我以前搭建过一次了，但是上次留的坑太多了，所以就想着有时间重新搞一次。不过我这次tm的忘了备份就把写的博客都删了😭，幸好就只有几篇😇，不然我真的会伤心死。搭建博客只能说是纯纯的体力活，这次是从昨天19点左右搞到今天0点30左右，比上次用的时间少多了，踩的坑也更少了，熟能生巧啊真是。上次搭建了博客也没怎么宣传，这次就把能贴上我个人博客网址的地方都贴上😈。然后就瞎扯一下近况吧。近期属于是刚期末考完，今天中午和舍友出去吃了自助餐，这是我这学期第一次外出，期末周基本每门课都是考前一天开始复习，要知道上学期的我考前一周开始复习最后都稀烂，不过这次有我的卷王队友带我复习，效率真的是起飞🛫。昨天考完了最后一门，好不容易可以好好休息，明天却要开始军训了，军训两周之后便是为期两周的初级项目实践，一周六天，一天八节课，真nm离谱💢。这个结束之后就是为期一个月左右的暑期集训。集训完估计就8.20左右了，到那时候我再看情况回不回家。（主要是看WHU的开学时间以及我那几个高中同学的开学时间，好久没见他们了啊。）</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>未来自己想干的挺多的，想在ACM赛场上拿金牌，想有好的项目经历，想保研（毕竟能在学校在呆三年，虽然我很讨厌上学，但是我清楚的知道我会更讨厌打工），现在第三项估计已经凉了，不过我对科研也不大感兴趣，希望自己能在前两项上取得好成绩，更希望自己能享受这个过程，现在还记得刚学算法时闫老师的某句话，大致意思就是：学算法为什么那么爽，你想想你每AC一道题都像吸毒一样（危险的比喻），肯定爽。未来这个博客就随便写写我的随笔，算法学习笔记，题解，以及游记（疫情快点彻底结束吧！我想打线下赛，主要是想去旅游🤤）。就这样吧，就tm随便写了点就一点了，睡了睡了，明天早起肝C++大作业报告。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

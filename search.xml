<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kruskal重构树</title>
      <link href="/2022/07/28/kruskal-chong-gou-shu/"/>
      <url>/2022/07/28/kruskal-chong-gou-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后缀自动机</title>
      <link href="/2022/07/27/hou-zhui-zi-dong-ji/"/>
      <url>/2022/07/27/hou-zhui-zi-dong-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组</title>
      <link href="/2022/07/27/hou-zhui-shu-zu/"/>
      <url>/2022/07/27/hou-zhui-shu-zu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里讲的是倍增做法，至于DC3的做法，看我以后能不能学会吧。</p></blockquote><h2 id="作用介绍"><a href="#作用介绍" class="headerlink" title="作用介绍"></a>作用介绍</h2><p>我们有一个长度为$n$的字符串$s$，下标从$1$开始，我们用编号为$i$的后缀表示从$i$位置开始的后缀，这样就一共有$n$个后缀，后缀数组的作用就是将所有的后缀按字典序排序(从小到大)，我们用$sa$数组、$rk$数组、$height$数组存储求得的信息</p><p>$sa[i]$代表排名第$i$位的后缀的编号</p><p>$rk[i]$代表编号为$i$的后缀的排名</p><p>$height[i]$代表排名为$i$的后缀和排名为$i-1$的后缀的最长公共前缀，很明显，$height[1]=0$</p><p>如果$s=aababb$，那么我们有6个后缀：$aababb、ababb、babb、abb、bb、b$，最后我们求得的各数组值如下(下标从小到大)：</p><p>$sa：1，2，4，6，3，5$</p><p>$rk：1，2，5，3，6，4$</p><p>$height：0，1，2，0，1，1$</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>我们先按照每个后缀的第一个字符对所有后缀排序，第一个字符相同的后缀之间的相对顺序不变(基数排序，时间复杂度$O(n)$)，然后倍增地进行。</p><p>当所有后缀按前$k$个字符排好序后，我们考虑按前$2k$个字符来排序，前$k$个字符为第一关键字，$k+1\sim 2k$个字符为第二关键字，先按第二关键字排序，再按第一关键字排序，其中使用离散化。</p><p>然后对于求$height[i]$，设$h[i]$表示$height[rk[i]]$，即排名为i的后缀与排名在它前一个的后缀的最长公共前缀，而$h[i]\ge h[i-1]-1$，我们可以$O(n)$的求出$height$数组，时间复杂度分析类似于$KMP$算法，采用的是势能分析法。</p><p>关于$h[i]\ge h[i-1]-1$的证明：</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202207262218712.png" alt="image-20220726221845492"></p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202207262219171.png" alt="image-20220726221910009"></p><p><strong>Talk is cheap，show me the code.</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>$copy$的$y$总代码，加了注释，顺便把可能越界的地方改了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int n, m;char s[N];//sa是排名对应的编号,rk是编号对应的排名int sa[N], x[N], y[N], c[N], rk[N], height[N];//x是按第一关键字的排名,y是按第二关键字的排名,x是编号对应排名,y是排名对应编号void get_sa(){    //所有后缀首先按第一个字符进行基数排序    for (int i = 1; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ;    for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1];    //从后往前可以保证排序稳定    for (int i = n; i; i -- ) sa[c[x[i]] -- ] = i;    for (int k = 1; k &lt;= n; k &lt;&lt;= 1){//倍增,当前已按前k个字母排好序        int num = 0;                //按第二关键字排序        for (int i = n - k + 1; i &lt;= n; i ++ ) y[ ++ num] = i;//后k个字符没有第二关键字,因此排名最靠前        for (int i = 1; i &lt;= n; i ++ )//其它的取决于它前面k个位置处的第一关键字的排名,按第一关键字的排名顺序枚举            if (sa[i] &gt; k)                y[ ++ num] = sa[i] - k;                //按第一关键字排序        for (int i = 1; i &lt;= m; i ++ ) c[i] = 0;        for (int i = 1; i &lt;= n; i ++ ) c[x[i]] ++ ;        for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1];        //从后往前,保证第一关键字相同时第二关键字排好的相对顺序不变        //y[i]是排名为i的对应的编号,看不懂的推荐看看基数排序的双关键字排序        for (int i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = 0;        //y没用了        swap(x, y);        //排名为1的对应编号的排名为1        x[sa[1]] = 1, num = 1;        for (int i = 2; i &lt;= n; i ++ )            //看看是否有相同的,第一关键字和第二关键字都要比较            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; sa[i] + k &lt;= n &amp;&amp; sa[i - 1] + k &lt;= n &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++ num;        if (num == n) break;//已经排完了        m = num;//修改下离散的范围    }}void get_height(){    for (int i = 1; i &lt;= n; i ++ ) rk[sa[i]] = i;    for (int i = 1, k = 0; i &lt;= n; i ++ ){        if (rk[i] == 1) continue;        if (k) k -- ;        int j = sa[rk[i] - 1];        while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k ++ ;        height[rk[i]] = k;    }}int main(){    scanf("%s", s + 1);//读入需要处理的字符串    n = strlen(s + 1), m = 122;//m是离散化的数据范围,因为一般处理的字符中ASCII码最大的也就是z,所以这里赋值为122    get_sa();    get_height();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求不同子串个数"><a href="#求不同子串个数" class="headerlink" title="求不同子串个数"></a>求不同子串个数</h2><p>给定一个字符串，有了$height$数组，我们就很容易求出不同子串个数(即字典序不同)，我们已经按字典序给所有的后缀排好序，不同子串个数就相当于所有后缀的不同前缀个数。我们按字典序从前往后遍历所有后缀。</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202207271423852.png" alt="image-20220727142323709"></p><p>很明显，第一个后缀的所有前缀都应该被我们统计进答案，而第二个后缀的前缀恰有$height[i]$个是与前面的重复的，这样我们扫一遍$height$数组即可得到本质不同子串个数了。有同学可能会问，你这样统计到排名为i的后缀时，有没有可能与前面的后缀有一些公共前缀没减去？答案是：<strong>不会</strong>！</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202207271429499.png" alt="image-20220727142927454"></p><p>当出现如图所示情况时我们会有上述错误，然而这种清况<strong>不可能出现</strong>，因为我们在上面得到了$lcp(i,j)=min(lcp(i,k),lcp(k,j))(i\le k \le j)$</p><p>代码很简单。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LL ans=0;//记录答案for(int i=1;i&lt;=n;i++){//根据排名遍历    int id=sa[i];//找到对应编号    int len=n-id+1;//计算出长度    ans+=len-height[i];//统计答案}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后缀排序"><a href="#后缀排序" class="headerlink" title="后缀排序"></a>后缀排序</h2><p>板子题：<a href="https://www.luogu.com.cn/problem/P3809">后缀排序</a></p><h2 id="品酒大会"><a href="#品酒大会" class="headerlink" title="品酒大会"></a>品酒大会</h2><p>$NOI2015$：<a href="https://www.luogu.com.cn/problem/P2178">品酒大会</a></p><p>两杯酒$l、r$是$k$相似的，等价于$lcp(i，j)\ge k$，当我们求两杯$k$相似的酒相调的方案数时，我们可以考虑该字符串所有后缀按字典序排序的序列，我们发现可以相调的酒被分成了若干段。(因为我们有性质:$lcp(i,j)=min(lcp(i,k),lcp(k,j))(i\le k \le j)$)，我们只需要知道这些段的大小$sz$，方案数就是$sz\times (sz-1)\div 2$，然后我们考虑倒着来求，因为这样的话刚开始所有酒都是单独一段，我们后面只需不断合并，这样比正着分裂好做得多(我还不知道正着能不能做)，合并的同时维护每一段的最大值、次大值、最小值、次小值用来求可以得到的最大美味度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;#define x first #define y second#define endl '\n'#define lowbit(x) ((x)&amp;(-x))#define all(x) (x).begin(),(x).end()#define mp make_pair#define pb push_back#define SZ(x) ((int)(x).size())#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;typedef pair&lt;int,int&gt; PII;typedef vector&lt;int&gt; VI;typedef long long LL;typedef unsigned long long ULL;typedef double DB;mt19937 randint(random_device{}());mt19937_64 randLL(random_device{}());template&lt;typename T=int&gt; T gcd(T a,T b){return b?gcd(b,a%b):a;}template&lt;typename T=int&gt; T qmi(T a,T b,T p){T res=1;while(b){if(b&amp;1)res=(LL)res*a%p;b&gt;&gt;=1;a=(LL)a*a%p;}return res%p;}template&lt;typename T=int&gt;T read(){T x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}//并查集板子struct DSU{vector&lt;int&gt; p,sz;DSU(int n=0):p(n+1),sz(n+1){for(int i=1;i&lt;=n;i++) p[i]=i,sz[i]=1;}void init(int n){p.resize(n+1);sz.resize(n+1);for(int i=1;i&lt;=n;i++) p[i]=i,sz[i]=1;}int find(int x){if(p[x]!=x) p[x]=find(p[x]);return p[x];}void merge(int a,int b){a=find(a),b=find(b);if(a!=b) p[a]=b,sz[b]+=sz[a];}bool same(int a,int b){a=find(a),b=find(b);return a==b;}int cnt(){int res=0;for(int i=1;i&lt;p.size();i++){if(p[i]==i) res++;}return res;}};//----------------------------------------head------------------------------------const int mod=1e9+7,N=3e5+10;const LL INF=2e18;const double eps=1e-6;using PLL=pair&lt;LL,LL&gt;;int n,m,w[N];char s[N];int sa[N],x[N],y[N],c[N],rk[N],height[N];LL ma2[N],mi2[N],mi[N],ma[N];vector&lt;int&gt; to[N];PLL ans[N];LL cnt,maxans=-INF;DSU dsu;//后缀数组板子void get_sa(){for(int i=1;i&lt;=n;i++) c[x[i]=s[i]]++;for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];for(int i=n;i;i--) sa[c[x[i]]--]=i;for(int k=1;k&lt;=n;k&lt;&lt;=1){int num=0;for(int i=n-k+1;i&lt;=n;i++) y[++num]=i;for(int i=1;i&lt;=n;i++)if(sa[i]&gt;k)y[++num]=sa[i]-k;for(int i=1;i&lt;=m;i++) c[i]=0;for(int i=1;i&lt;=n;i++) c[x[i]]++;for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];for(int i=n;i;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;swap(x,y);x[sa[1]]=1,num=1;for(int i=2;i&lt;=n;i++)x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?num:++num;if(num==n) break;m=num;}}void get_height(){for(int i=1;i&lt;=n;i++) rk[sa[i]]=i;for(int i=1,k=0;i&lt;=n;i++){if(rk[i]==1) continue;if(k) k--;int j=sa[rk[i]-1];while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) k++;height[rk[i]]=k;}}LL get(int x){return 1ll*(x-1)*x/2;}void calc(int x){for(auto tar:to[x]){//每次是合并它和它的前一个,tar是排名int a=dsu.find(tar-1),b=dsu.find(tar);cnt-=get(dsu.sz[a])+get(dsu.sz[b]);//减去原来这两块的贡献dsu.merge(a,b);//把a合并到b上cnt+=get(dsu.sz[b]);//加上新的一块的贡献        //维护新一块的最大值、最小值、次大值、次小值if(ma[a]&gt;=ma[b]){ma2[b]=max(ma2[a],ma[b]);ma[b]=ma[a];}else ma2[b]=max(ma[a],ma2[b]);if(mi[a]&lt;=mi[b]){mi2[b]=min(mi2[a],mi[b]);mi[b]=mi[a];}else mi2[b]=min(mi2[b],mi[a]);        //更新答案maxans=max(maxans,max(mi[b]*mi2[b],ma[b]*ma2[b]));}if(maxans==-INF) ans[x]={cnt,0};else ans[x]={cnt,maxans};}void solve(){n=read(),m='z';dsu.init(n);scanf("%s",s+1);for(int i=1;i&lt;=n;i++) w[i]=read();get_sa();get_height();for(int i=2;i&lt;=n;i++) to[height[i]].pb(i);//因为我们每次合并是和前一个合并，因此不需要0for(int i=1;i&lt;=n;i++){//按排名顺序记录每一段的信息ma[i]=mi[i]=w[sa[i]];ma2[i]=-INF,mi2[i]=INF;}for(int i=n-1;i&gt;=0;i--) calc(i);//倒着合并，先把height[i]==n-1的合并,然后以此类推for(int i=0;i&lt;n;i++) printf("%lld %lld\n",ans[i].x,ans[i].y);}signed main(){int t=1;while(t--) solve();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生成魔咒"><a href="#生成魔咒" class="headerlink" title="生成魔咒"></a>生成魔咒</h2><p>$SDOI2016$：<a href="https://www.luogu.com.cn/problem/P4070">生成魔咒</a></p><p>之前我们已经介绍了如何求一个字符串的不同子串个数，这次我们要求的<strong>好像</strong>是一个动态的问题，这让我们难以下手。然而，我们巧妙转换，我们倒着读入字符串，而一个字符串不管正着还是倒着其不同子串个数还是一样的，每次从前面删除一个字符，就可以完成题目的要求，删除的话我们使用一个双链表，$O(1)$删除。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;#define x first #define y second#define endl '\n'#define lowbit(x) ((x)&amp;(-x))#define all(x) (x).begin(),(x).end()#define mp make_pair#define pb push_back#define SZ(x) ((int)(x).size())#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;typedef pair&lt;int,int&gt; PII;typedef vector&lt;int&gt; VI;typedef long long LL;typedef unsigned long long ULL;typedef double DB;mt19937 randint(random_device{}());mt19937_64 randLL(random_device{}());template&lt;typename T=int&gt; T gcd(T a,T b){return b?gcd(b,a%b):a;}template&lt;typename T=int&gt; T qmi(T a,T b,T p){T res=1;while(b){if(b&amp;1)res=(LL)res*a%p;b&gt;&gt;=1;a=(LL)a*a%p;}return res%p;}template&lt;typename T=int&gt;T read(){T x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}//----------------------------------------head------------------------------------const int INF=0x3f3f3f3f,mod=1e9+7,N=1e5+10;const double eps=1e-6;unordered_map&lt;int,int&gt; cast;int n,m;LL res,ans[N];int u[N],d[N];int s[N];int sa[N],x[N],y[N],c[N],rk[N],height[N];//sa[i]是i排名对应的编号,rk[i]是编号对应排名,height[i]是排名为i的与i-1的lcp,x[i]是编号对应排名,y[i]是排名对应编号void get_sa(){for(int i=1;i&lt;=n;i++) c[x[i]=s[i]]++;for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];for(int i=n;i;i--) sa[c[x[i]]--]=i;for(int k=1;k&lt;=n;k&lt;&lt;=1){int num=0;for(int i=n-k+1;i&lt;=n;i++) y[++num]=i;for(int i=1;i&lt;=n;i++)if(sa[i]&gt;k)y[++num]=sa[i]-k;for(int i=1;i&lt;=m;i++) c[i]=0;for(int i=1;i&lt;=n;i++) c[x[i]]++;for(int i=2;i&lt;=m;i++) c[i]+=c[i-1];for(int i=n;i;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;swap(x,y);x[sa[1]]=1,num=1;for(int i=2;i&lt;=n;i++)x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?num:++num;if(num==n) break;m=num;}}void get_height(){for(int i=1;i&lt;=n;i++) rk[sa[i]]=i;for(int i=1,k=0;i&lt;=n;i++){if(rk[i]==1) continue;if(k) k--;int j=sa[rk[i]-1];while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) k++;height[rk[i]]=k;}}int get(int x){if(cast.count(x)) return cast[x];return cast[x]=++m;}void solve(){n=read();for(int i=n;i;i--) s[i]=read(),s[i]=get(s[i]);for(int i=1;i&lt;=n;i++) u[i]=i-1,d[i]=i+1;//这里维护的是排名的双链表，从上往下维护，u[i]表示i上面的那个串的排名，d[i]表示i下面的那个串的排名get_sa();get_height();u[n+1]=n,d[0]=1;for(int i=1;i&lt;=n;i++)res+=n-sa[i]+1-height[i];for(int i=1;i&lt;=n;i++){//删除编号为i的int k=rk[i],j=d[k];//找到该编号对应的排名以及它的后一名ans[i]=res;        //先减去它有贡献的地方res-=n-sa[k]+1-height[k];res-=n-sa[j]+1-height[j];height[j]=min(height[j],height[k]);//lcp(i,j)=min(lcp(i,k),lcp(k,j))(i&lt;=k&lt;=j)d[u[k]]=j,u[j]=u[k];//删除这一名res+=n-sa[j]+1-height[j];//加上新的}for(int i=n;i;i--) cout&lt;&lt;ans[i]&lt;&lt;endl;//倒着输出}signed main(){int t=1;while(t--) solve();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2022/06/21/xian-duan-shu/"/>
      <url>/2022/06/21/xian-duan-shu/</url>
      
        <content type="html"><![CDATA[<p>本文章以线段树的拓展为主，不会讲解基础内容。另外本人目前比较忙，将在军训和第三学期后更新内容，现只列出大纲和例题。</p><h2 id="线段树妙用"><a href="#线段树妙用" class="headerlink" title="线段树妙用"></a>线段树妙用</h2><p><a href="https://ac.nowcoder.com/acm/contest/19684/B">HH的项链</a></p><h2 id="多tag后效性处理"><a href="#多tag后效性处理" class="headerlink" title="多tag后效性处理"></a>多tag后效性处理</h2><p><a href="https://www.luogu.com.cn/problem/P2023">维护序列</a></p><h2 id="势能线段树"><a href="#势能线段树" class="headerlink" title="势能线段树"></a>势能线段树</h2><p><a href="https://codeforces.com/gym/103107/problem/A">And RMQ</a></p><h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><p><a href="https://codeforces.com/contest/1009/problem/F">Dominant Indices</a></p><h2 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title="线段树分裂"></a>线段树分裂</h2><p><a href="https://codeforces.com/contest/911/problem/G">Mass Change Queries</a></p><h2 id="可持久化线段树（主席树）"><a href="#可持久化线段树（主席树）" class="headerlink" title="可持久化线段树（主席树）"></a>可持久化线段树（主席树）</h2><p><a href="https://codeforces.com/gym/103687/problem/F">Easy Fix</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希</title>
      <link href="/2022/06/20/zi-fu-chuan-ha-xi/"/>
      <url>/2022/06/20/zi-fu-chuan-ha-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>哈希是一种映射方法，我们用哈希把万物映射成一个整数值，字符串哈希就是把字符串映射为一个整数值，这样我们就能快速判断两个字符串是否相同。字母集$T$就是我们用到所有字母的集合，$|T|$就是其大小。$H$为哈希函数,$S$为字符串，$n$为其长度，$H(S)$即为字符串$S$的哈希值，$mod$是模数</p></blockquote><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>字符串哈希最常用的方法就是把整个字符串当成一个$K$进制数，其中$K\ge |T|$，而我们遇到的题目中一般都满足$|T|\le 128$，我们可以选择$K=131、137$等等数值，<strong>最好是质数</strong>，因为我们计算的时候整数的值过大，我们需要取模。</p><p>按照这种方法，假设有字符串$S$，且其下标从1开始，那么$H(S)=\sum_{i=1}^{n}S[i]\times K^{n-i+1}$，这个值过大，我们需要取模，模数肯定也要选择<strong>比较大的质数</strong>，模数小会很容易出现冲突，即两个并不相同的字符串哈希值相同，我们可以取$mod=1e9+7、1e9+9、1610612741$，其中第三个是比较好的哈希模数。（因为前两个用的太多了，出题人更容易卡我们）但是就算如此，当我们需要检测的次数特别多时，我们还是很容易出错，因此我们可以用不同的$K$和$mod$算两个哈希值，这样出错概率就会<strong>大大降低</strong>。</p><p>另外，根据<a href="https://baike.baidu.com/item/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA/2715290?fr=aladdin">生日悖论</a>，我们使用的<strong>模数最好大于等于检测次数的平方</strong>。</p><h2 id="子串哈希"><a href="#子串哈希" class="headerlink" title="子串哈希"></a>子串哈希</h2><p>由上面的内容，我们很容易知道$H(S[l\sim r])=(S[l]\times K^{r-l}+\cdots + S[r])%mod$。</p><p>假设我们令$F[i]=H(S[1\sim i])$，那么有</p><p>$F[l-1]=(S[1]\times K^{l-2}+S[2]\times K^{l-3}+\cdots+S[l-1])%mod$</p><p>$F[r]=(S[1]\times K^{r-1}+S[2]\times K^{r-2}+\cdots +S[r])%mod$</p><p>我们易知$H(S[l\sim r])=F[r]-F[l]\times K^{r-l+1}$</p><p>因此我们只要求出$S$对应的$F$，就能快速求出其子串的哈希。</p><p>而我们也易得$F[i+1]=F[i]\times K+S[i+1]$</p><p>另外，如果给我们$H(S[l_{1}\sim r_{1}])$和$H(S[l_{2}\sim r_{2}])$那么我们可以快速得到这两个字串拼接起来后得到的字符串的哈希值为$H(S[l_{1}\sim r_{1}])\times K^{r_{2}-l_{2}+1}+H(S[l_{2}\sim r_{2}])$，由此我们想到如果我们要修改字符串的话，我们就可以用线段树来维护字符串的哈希值了！</p><h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><p>这几天军训比较懒，所以就没有结合例题来讲，放几道推荐题目吧。</p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3370">字符串哈希</a></p><p>思维题+用字符串哈希判断回文串：<a href="https://codeforces.com/gym/103729/problem/J">Palindrome Reversion</a></p><p>二分+字符串哈希找最长回文串：<a href="https://www.luogu.com.cn/problem/SP7586">Number of Palindromes</a></p><p>线段树+字符串哈希：<a href="https://codeforces.com/contest/580/problem/E">Kefa and Watch</a></p>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2022/06/19/bing-cha-ji/"/>
      <url>/2022/06/19/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章我们不再讲解并查集的基础知识，主要讲解并查集的一些拓展用法，需要补一下基础知识的同学我推荐这一篇文章：<a href="https://blog.csdn.net/weixin_38279101/article/details/112546053">并查集</a>，另外这篇文章里讲到的按秩合并，也可以是把小的集合合并到大的集合上面，这样更容易代码实现，我们只需多维护一个集合的大小就可以了。另外按秩合并在不用可撤销并查集的地方我们基本上用不到，毕竟我们路径压缩后就很优秀了，而可撤销并查集不能使用路径压缩，我们为了保证效率就会使用按秩合并。另外提一嘴，使用路径压缩的并查集平均复杂度就是$O(n)$了。</p></blockquote><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>我们在维护并查集的同时维护每个节点到当前它的父亲节点的距离，就能维护各个元素之间一些具有传递性的属性。感觉这一点干讲不知道怎么讲，我们就拿道题来看吧，第十三届篮球包（蓝桥杯）省赛CA组最后一题：</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206190959038.png" alt="image-20220619095950928"></p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191000153.png" alt="image-20220619100012085"></p><p>首先我们看到区间和肯定会想到并查集，我们用$s_{i}$表示$\sum_{j=1}^{i} A_{i}$，那么如果我们已知$\sum_{i=l}^{r} A_{i}$，就相当于知道了$s_{r}-s_{l-1}$，如果最终只是问我们答案能否确定，那肯定很简单，我们用并查集维护$s$的集合，我们只需要先合并它给我们的所有$r$和$l-1$，然后查询的时候看$l-1$和$r$是否在一个集合内即可。然后我们另外开一个数组$d$记录每个点$x$的父亲节点和它之间的差$s[p[x]]-s[x]$， $p[x]$表示$x$的父亲，至于$d$数组的初始化就很简单了，$d[i]=0$，因为刚开始$p[i]=i$，然后先看代码，我再具体讲解。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> l<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//read就是写的快读</span>LL sum<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>l<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//前缀和为s[r]-s[l-1]</span>LL a<span class="token operator">=</span>l<span class="token punctuation">,</span>b<span class="token operator">=</span>r<span class="token punctuation">;</span>l<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找到l-1，r的父亲p[l-1],p[r]</span><span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">!=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>    p<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token punctuation">;</span><span class="token comment">//合并集合，这里的l，r已经不是原来的l，r</span>    d<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>sum<span class="token operator">+</span>d<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">-</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//更新距离，为什么这么写，看下面的图应该就理解了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191142837.png" alt="image-20220619114246792"></p><p>由于$find$函数调用的途中我们会改变节点的父亲，因此我们的$find$函数也需要改写。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> root<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先记录下找到的父亲</span>        d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+=</span>d<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//x到新父亲的距离=x到旧父亲的距离+旧父亲到新父亲的距离</span>        p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191156491.png" alt="image-20220619115605445"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//查询就比较简单了</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">--</span><span class="token punctuation">;</span>LL x<span class="token operator">=</span>a<span class="token punctuation">,</span>y<span class="token operator">=</span>b<span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">!=</span>b<span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"UNKNOWN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">-</span>d<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//注意，这里是d[x]-d[y]而不是d[a]-d[b]，因为a，b已经变成它们的父亲了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们差不多了解了带权并查集，这里我们维护的是元素间的差，我们也可以维护其它类型的权值，大家可以自己找点题练习。</p><h2 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h2><p>我们知道并查集能维护具有传递性的关系，但当我们遇到诸如“敌人的敌人是朋友”这类关系时，普通的并查集就没那么好用了，这时候我们的扩展域并查集就登场了。我们把并查集的规模扩大一倍，并划分为两个种类，在相同种类中合并两个元素表示他们是朋友，在不同种类中合并表达他们是敌人，这样一个人敌人的敌人就和他在同一个种类中，就维护了“敌人的敌人是朋友”的这种关系。</p><p>我们来道例题并写出代码加深一下理解。</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191250142.png" alt="image-20220619125054061"></p><p>我们还是用前缀和的思想，用$sum[i]$表示$s[1\sim i]$中1的个数，如果$l\sim r$中有偶数个$1$，我们易知$sum[l-1]$和$sum[r]$的奇偶性相同，奇数个则相反，而对于$sum[i]$，假设$sum[y]$与它奇偶性相反，那么与$sum[y]$奇偶性相反的数奇偶性与$sum[i]$相同，符合我们上面阐述的关系，因此这题我们可以用扩展域并查集来写。另外这题$N$的范围较大，需要离散化，我图个方便就直接写了，懂思路才是最重要的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//我们用0~n表示0~n的第一个种类，n+1~2*n+1表示0~n的第二个种类</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">int</span> pa1<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>pb1<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pa2<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token operator">+</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>pb2<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token operator">+</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是偶数个时，这二者奇偶性相同</span><span class="token keyword">if</span><span class="token punctuation">(</span>pa1<span class="token operator">==</span>pb2<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//如果发现a，b奇偶性不同，说明矛盾</span><span class="token comment">//否则无矛盾，正常合并</span>p<span class="token punctuation">[</span>pa1<span class="token punctuation">]</span><span class="token operator">=</span>pb1<span class="token punctuation">;</span>p<span class="token punctuation">[</span>pa2<span class="token punctuation">]</span><span class="token operator">=</span>pb2<span class="token punctuation">;</span><span class="token comment">//奇数的情况也差不多，就不多写了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外这题也能用带权并查集来写，我们维护的权值只有1和0，两点之间距离为0时说明奇偶性相同，为1时说明奇偶性不同，然后计算距离时对2取模即可。</p><p>最后留一道不错的练习题：<a href="https://www.luogu.com.cn/problem/P2024">食物链</a>(带权并查集和扩展域并查集都能写)</p><h2 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h2><p>顾名思义，可撤销并查集就是能撤销我们的合并操作的并查集，要撤销，我们就需要存储每一次修改的信息，然后就行回退，这时再使用路径压缩就会出现问题，如图。</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191353327.png" alt="image-20220619135318193"></p><p>因此我们使用按秩合并，此时每次find的时间复杂度为$O(log n)$，那我们怎么撤销呢？我们发现，我们每次合并只会改变一个集合的大小和一个点的父亲，我们把这些都记录下来，就能撤销了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> his_p<span class="token punctuation">,</span>his_sz<span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>sz<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//sz[i]表示以i为根的集合的大小，初始时sz[i]=1</span><span class="token comment">//我们每进行一次合并his_p和his_sz的就会多一个元素，因此我们可以根据vector的大小来标识不同的历史版本</span><span class="token comment">//不带路径压缩的find</span><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span>x<span class="token punctuation">)</span> x<span class="token operator">=</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> x<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token comment">//合并部分代码</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> pa<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>pb<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>pa<span class="token operator">==</span>pb<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token operator">&lt;</span>sz<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>       his_sz<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>pa<span class="token punctuation">,</span>sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//pa的大小改变了</span>       sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token operator">=</span>sz<span class="token punctuation">[</span>pa<span class="token punctuation">]</span><span class="token operator">+</span>sz<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//小的合并到大的上，即pb合并到pa上</span>       his_p<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>pb<span class="token punctuation">,</span>p<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//pb的父亲改变了</span>       p<span class="token punctuation">[</span>pb<span class="token punctuation">]</span><span class="token operator">=</span>pa<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token comment">//撤销</span><span class="token keyword">void</span> <span class="token function">roll</span><span class="token punctuation">(</span><span class="token keyword">int</span> his<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//回到vector大小为his的版本</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>his_p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>his<span class="token punctuation">)</span><span class="token punctuation">{</span>           p<span class="token punctuation">[</span>his_p<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">=</span>his_p<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>           his_p<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           sz<span class="token punctuation">[</span>his_sz<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">=</span>his_sz<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>           his_sz<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后丢道练习题：<a href="https://codeforces.com/contest/891/problem/C">Envy</a></p><p>并查集就写到这里了，最重要的还是刷题练习！😋</p><h2 id="废话部分"><a href="#废话部分" class="headerlink" title="废话部分"></a>废话部分</h2><p>今天上午领了军训服装，明天就要开始军训了，祈祷下面两周天天下雨🙏😭。.</p><p>另外这个latex公式加载需要一些时间，因此公式炸了耐心等一下估计就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客记</title>
      <link href="/2022/06/18/da-jian-bo-ke-ji/"/>
      <url>/2022/06/18/da-jian-bo-ke-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>大家好，我是来自河南周口的一名大学生，没错，就是那个流出人口数全国第一的城市。虽然我来自一个很卷的地方，但我真的一点都不卷，即使学校逼着我们卷。高中三年我看了不少小说，具体数目实在不记得了，估计在50~100本之间？甚至高三还在看很多小说，还TM犯贱地看了《人间失格》，还看了一堆《看天下》，《环球人物》这类的杂志。高考挺让人失望的（指让学校），最后为了稳保我能上计算机专业，我选择了WHU，大一上学期偶然接触了算法竞赛，自那以后便一发不可收拾，即使临近期末考试并且我还没复习，我也会老想着算法，它和数学挺像的，但我感觉它比数学更迷人。现在我应该算是WHU的一名ACMer？可是比赛却打的稀碎，校内新生赛究极坐牢，蓝桥杯耻辱省二，湖北省赛被题目暴打，一个字概括我：菜👎。专业分流选了软工。目前爱好：单推真白花音；打rouge类游戏；算法竞赛，打乒乓球。</p><h1 id="简单记录"><a href="#简单记录" class="headerlink" title="简单记录"></a>简单记录</h1><p>现在是2022年6月18日0点32分，现在差不多搞完了我的博客搭建，其实我以前搭建过一次了，但是上次留的坑太多了，所以就想着有时间重新搞一次。不过我这次tm的忘了备份就把写的博客都删了😭，幸好就只有几篇😇，不然我真的会伤心死。搭建博客只能说是纯纯的体力活，这次是从昨天19点左右搞到今天0点30左右，比上次用的时间少多了，踩的坑也更少了，熟能生巧啊真是。上次搭建了博客也没怎么宣传，这次就把能贴上我个人博客网址的地方都贴上😈。然后就瞎扯一下近况吧。近期属于是刚期末考完，今天中午和舍友出去吃了自助餐，这是我这学期第一次外出，期末周基本每门课都是考前一天开始复习，要知道上学期的我考前一周开始复习最后都稀烂，不过这次有我的卷王队友带我复习，效率真的是起飞🛫。昨天考完了最后一门，好不容易可以好好休息，明天却要开始军训了，军训两周之后便是为期两周的初级项目实践，一周六天，一天八节课，真nm离谱💢。这个结束之后就是为期一个月左右的暑期集训。集训完估计就8.20左右了，到那时候我再看情况回不回家。（主要是看WHU的开学时间以及我那几个高中同学的开学时间，好久没见他们了啊。）</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>未来自己想干的挺多的，想在ACM赛场上拿金牌，想有好的项目经历，想保研（毕竟能在学校在呆三年，虽然我很讨厌上学，但是我清楚的知道我会更讨厌打工），现在第三项估计已经凉了，不过我对科研也不大感兴趣，希望自己能在前两项上取得好成绩，更希望自己能享受这个过程，现在还记得刚学算法时闫老师的某句话，大致意思就是：学算法为什么那么爽，你想想你每AC一道题都像吸毒一样（危险的比喻），肯定爽。未来这个博客就随便写写我的随笔，算法学习笔记，题解，以及游记（疫情快点彻底结束吧！我想打线下赛，主要是想去旅游🤤）。就这样吧，就tm随便写了点就一点了，睡了睡了，明天早起肝C++大作业报告。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

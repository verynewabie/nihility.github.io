<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并查集</title>
      <link href="/2022/06/19/bing-cha-ji/"/>
      <url>/2022/06/19/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章我们不再讲解并查集的基础知识，主要讲解并查集的一些拓展用法，需要补一下基础知识的同学我推荐这一篇文章：<a href="https://blog.csdn.net/weixin_38279101/article/details/112546053">并查集</a>，另外这篇文章里讲到的按秩合并，也可以是把小的集合合并到大的集合上面，这样更容易代码实现，我们只需多维护一个集合的大小就可以了。另外按秩合并在不用可撤销并查集的地方我们基本上用不到，毕竟我们路径压缩后就很优秀了，而可撤销并查集不能使用路径压缩，我们为了保证效率就会使用按秩合并。另外提一嘴，使用路径压缩的并查集平均复杂度就是$O(n)$了。</p></blockquote><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>我们在维护并查集的同时维护每个节点到当前它的父亲节点的距离，就能维护各个元素之间一些具有传递性的属性。感觉这一点干讲不知道怎么讲，我们就拿道题来看吧，第十三届篮球包（蓝桥杯）省赛CA组最后一题：</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206190959038.png" alt="image-20220619095950928"></p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191000153.png" alt="image-20220619100012085"></p><p>首先我们看到区间和肯定会想到并查集，我们用$s_{i}$表示$\sum_{j=1}^{i} A_{i}$，那么如果我们已知$\sum_{i=l}^{r} A_{i}$，就相当于知道了$s_{r}-s_{l-1}$，如果最终只是问我们答案能否确定，那肯定很简单，我们用并查集维护$s$的集合，我们只需要先合并它给我们的所有$r$和$l-1$，然后查询的时候看$l-1$和$r$是否在一个集合内即可。然后我们另外开一个数组$d$记录每个点$x$的父亲节点和它之间的差$s[p[x]]-s[x]$， $p[x]$表示$x$的父亲，至于$d$数组的初始化就很简单了，$d[i]=0$，因为刚开始$p[i]=i$，然后先看代码，我再具体讲解。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l=read(),r=read();//read就是写的快读LL sum=read();l--;//前缀和为s[r]-s[l-1]LL a=l,b=r;l=find(l),r=find(r);//找到l-1，r的父亲p[l-1],p[r]if(l!=r){    p[l]=r;//合并集合，这里的l，r已经不是原来的l，r    d[l]=sum+d[b]-d[a];//更新距离，为什么这么写，看下面的图应该就理解了}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191142837.png" alt="image-20220619114246792"></p><p>由于$find$函数调用的途中我们会改变节点的父亲，因此我们的$find$函数也需要改写。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){    if(p[x]!=x) {        int root=find(p[x]);//先记录下找到的父亲        d[x]+=d[p[x]];//x到新父亲的距离=x到旧父亲的距离+旧父亲到新父亲的距离        p[x]=root;    }    return p[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191156491.png" alt="image-20220619115605445"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//查询就比较简单了int a=read(),b=read();a--;LL x=a,y=b;a=find(a),b=find(b);if(a!=b) puts("UNKNOWN");else cout&lt;&lt;d[x]-d[y]&lt;&lt;endl;//注意，这里是d[x]-d[y]而不是d[a]-d[b]，因为a，b已经变成它们的父亲了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们差不多了解了带权并查集，这里我们维护的是元素间的差，我们也可以维护其它类型的权值，大家可以自己找点题练习。</p><h2 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h2><p>我们知道并查集能维护具有传递性的关系，但当我们遇到诸如“敌人的敌人是朋友”这类关系时，普通的并查集就没那么好用了，这时候我们的扩展域并查集就登场了。我们把并查集的规模扩大一倍，并划分为两个种类，在相同种类中合并两个元素表示他们是朋友，在不同种类中合并表达他们是敌人，这样一个人敌人的敌人就和他在同一个种类中，就维护了“敌人的敌人是朋友”的这种关系。</p><p>我们来道例题并写出代码加深一下理解。</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191250142.png" alt="image-20220619125054061"></p><p>我们还是用前缀和的思想，用$sum[i]$表示$s[1\sim i]$中1的个数，如果$l\sim r$中有偶数个$1$，我们易知$sum[l-1]$和$sum[r]$的奇偶性相同，奇数个则相反，而对于$sum[i]$，假设$sum[y]$与它奇偶性相反，那么与$sum[y]$奇偶性相反的数奇偶性与$sum[i]$相同，符合我们上面阐述的关系，因此这题我们可以用扩展域并查集来写。另外这题$N$的范围较大，需要离散化，我图个方便就直接写了，懂思路才是最重要的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; p(2*n+2);//我们用0~n表示0~n的第一个种类，n+1~2*n+1表示0~n的第二个种类int a=read(),b=read();a--;int pa1=find(a),pb1=find(b);int pa2=find(a+n+1),pb2=find(b+n+1);//是偶数个时，这二者奇偶性相同if(pa1==pb2) break;//如果发现a，b奇偶性不同，说明矛盾//否则无矛盾，正常合并p[pa1]=pb1;p[pa2]=pb2;//奇数的情况也差不多，就不多写了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外这题也能用带权并查集来写，我们维护的权值只有1和0，两点之间距离为0时说明奇偶性相同，为1时说明奇偶性不同，然后计算距离时对2取模即可。</p><p>最后留一道不错的练习题：<a href="https://www.luogu.com.cn/problem/P2024">食物链</a>(带权并查集和扩展域并查集都能写)</p><h2 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h2><p>顾名思义，可撤销并查集就是能撤销我们的合并操作的并查集，要撤销，我们就需要存储每一次修改的信息，然后就行回退，这时再使用路径压缩就会出现问题，如图。</p><p><img src="https://cartoonwqy.oss-cn-nanjing.aliyuncs.com/boke/202206191353327.png" alt="image-20220619135318193"></p><p>因此我们使用路径压缩，此时每次find的时间复杂度为$O(log n)$，那我们怎么撤销呢？我们发现，我们每次合并只会改变一个集合的大小和一个点的父亲，我们把这些都记录下来，就能撤销了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;pair&lt;int,int&gt;&gt; his_p,his_sz;int p[N],sz[N];//sz[i]表示以i为根的集合的大小，初始时sz[i]=1//我们每进行一次合并his_p和his_sz的就会多一个元素，因此我们可以根据vector的大小来标识不同的历史版本//不带路径压缩的findint find(int x){       while(p[x]!=x) x=p[x];       return x;   }//合并部分代码void merge(int a,int b){       int pa=find(a),pb=find(b);       if(pa==pb) return ;       if(sz[pa]&lt;sz[pb]) swap(pa,pb);       his_sz.push_back({pa,sz[pa]});//pa的大小改变了       sz[pa]=sz[pa]+sz[pb];//小的合并到大的上，即pb合并到pa上       his_p.push_back({pb,p[pb]});//pb的父亲改变了       p[pb]=pa;   }//撤销void roll(int his){//回到vector大小为his的版本       while(his_p.size()&gt;his){           p[his_p.back().first]=his_p.back().second;           his_p.pop_back();           sz[his_sz.back().first]=his_sz.back().second;           his_sz.pop_back();       }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后丢道练习题：<a href="https://codeforces.com/contest/891/problem/C">Envy</a></p><p>并查集就写到这里了，最重要的还是刷题练习！😋</p><h2 id="废话部分"><a href="#废话部分" class="headerlink" title="废话部分"></a>废话部分</h2><p>今天上午领了军训服装，明天就要开始军训了，祈祷下面两周天天下雨🙏😭。.</p><p>另外这个latex公式加载需要一些时间，因此公式炸了耐心等一下估计就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客记</title>
      <link href="/2022/06/18/zi-wo-jie-shao-ji-da-jian-bo-ke-ji/"/>
      <url>/2022/06/18/zi-wo-jie-shao-ji-da-jian-bo-ke-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>大家好，我是来自河南周口的一名大学生，没错，就是那个流出人口数全国第一的城市。虽然我来自一个很卷的地方，但我真的一点都不卷，即使学校逼着我们卷。高中三年我看了不少小说，具体数目实在不记得了，估计在50~100本之间？甚至高三还在看很多小说，还TM犯贱地看了《人间失格》，还看了一堆《看天下》，《环球人物》这类的杂志。高考挺让人失望的（指让学校），最后为了稳保我能上计算机专业，我选择了WHU，大一上学期偶然接触了算法竞赛，自那以后便一发不可收拾，即使临近期末考试并且我还没复习，我也会老想着算法，它和数学挺像的，但我感觉它比数学更迷人。现在我应该算是WHU的一名ACMer？可是比赛却打的稀碎，校内新生赛究极坐牢，蓝桥杯耻辱省二，湖北省赛被题目暴打，一个字概括我：菜👎。专业分流选了软工。目前爱好：单推真白花音；打rouge类游戏；算法竞赛，打乒乓球。</p><h1 id="简单记录"><a href="#简单记录" class="headerlink" title="简单记录"></a>简单记录</h1><p>现在是2022年6月18日0点32分，现在差不多搞完了我的博客搭建，其实我以前搭建过一次了，但是上次留的坑太多了，所以就想着有时间重新搞一次。不过我这次tm的忘了备份就把写的博客都删了😭，幸好就只有几篇😇，不然我真的会伤心死。搭建博客只能说是纯纯的体力活，这次是从昨天19点左右搞到今天0点30左右，比上次用的时间少多了，踩的坑也更少了，熟能生巧啊真是。上次搭建了博客也没怎么宣传，这次就把能贴上我个人博客网址的地方都贴上😈。然后就瞎扯一下近况吧。近期属于是刚期末考完，今天中午和舍友出去吃了自助餐，这是我这学期第一次外出，期末周基本每门课都是考前一天开始复习，要知道上学期的我考前一周开始复习最后都稀烂，不过这次有我的卷王队友带我复习，效率真的是起飞🛫。昨天考完了最后一门，好不容易可以好好休息，明天却要开始军训了，军训两周之后便是为期两周的初级项目实践，一周六天，一天八节课，真nm离谱💢。这个结束之后就是为期一个月左右的暑期集训。集训完估计就8.20左右了，到那时候我再看情况回不回家。（主要是看WHU的开学时间以及我那几个高中同学的开学时间，好久没见他们了啊。）</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>未来自己想干的挺多的，想在ACM赛场上拿金牌，想有好的项目经历，想保研（毕竟能在学校在呆三年，虽然我很讨厌上学，但是我清楚的知道我会更讨厌打工），现在第三项估计已经凉了，不过我对科研也不大感兴趣，希望自己能在前两项上取得好成绩，更希望自己能享受这个过程，现在还记得刚学算法时闫老师的某句话，大致意思就是：学算法为什么那么爽，你想想你每AC一道题都像吸毒一样（危险的比喻），肯定爽。未来这个博客就随便写写我的随笔，算法学习笔记，题解，以及游记（疫情快点彻底结束吧！我想打线下赛，主要是想去旅游🤤）。就这样吧，就tm随便写了点就一点了，睡了睡了，明天早起肝C++大作业报告。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
